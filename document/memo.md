ハフマン符号化の例
元のデータ: AABACD

頻度: A=3, B=1, C=1, D=1
ハフマン符号:
A=0, B=10, C=110, D=111
符号化結果: 00100110111
ウィル符号化の例
元のデータ: [10, 12, 13, 15, 18]

差分: [10, +2, +1, +2, +3]
符号化結果: 差分データ [+2, +1, +2, +3] を符号化。

//ワイル符号化とは
小さい値に少ないbit数を割り当てる符号化方式。
xには2進数の値が入る。
1-4   :     0xx
5-8   :    10xxx
9-16  :   110xxxx
17-32 :  1110xxxxxxx
33-64 : 11110xxxxxxxxxx
65-128:111110xxxxxxxxxxxxxx

具体例
元のデータ
[3, 4, 5, 6, 7, 8, 9, 10]

符号化結果
値 3 → 0xx → 011（3ビット）
値 4 → 0xx → 100（3ビット）
値 5 → 10xxx → 10100（5ビット）
値 6 → 10xxx → 10101（5ビット）
値 7 → 10xxx → 10110（5ビット）
値 8 → 10xxx → 10111（5ビット）
値 9 → 110xxxx → 1101001（7ビット）
値 10 → 110xxxx → 1101010（7ビット）
ビット数の比較
元のデータ（固定長符号化）:
8ビット × 8個 = 64ビット
圧縮後のデータ:
3 + 3 + 5 + 5 + 5 + 5 + 7 + 7 = 40ビット
→ 圧縮率: (40 / 64) × 100 ≈ 62.5%



はい、その通りです！ハフマン木では、**右に進むと `1`**、**左に進むと `0`** を割り当てます。このルールに従って、ルートノードから各葉ノード（シンボル）までの経路をビット列として記録します。このビット列が、そのシンボルに対応するハフマン符号になります。

---

### **具体的な流れ**
1. **ハフマン木の構築**:
   - 頻度の低いシンボルほど木の深い位置に配置されます。
   - 頻度の高いシンボルほど木の浅い位置に配置されます。

2. **符号の生成**:
   - ルートノードから葉ノードに向かって木を探索します。
   - 左の枝をたどる場合は `0` を、右の枝をたどる場合は `1` を追加します。

3. **符号の割り当て**:
   - 各葉ノードに到達したとき、その経路（ビット列）をそのシンボルの符号として割り当てます。

---

### **例**
#### ハフマン木の構造:
```
        [6]
       /   \
     A(3)  [3]
          /   \
        D(1)  [2]
              /   \
            B(1)  C(1)
```

#### 符号の割り当て:
- **A**: ルートから左に進む → `0`
- **B**: ルート → 右 → 右 → 左 → `110`
- **C**: ルート → 右 → 右 → 右 → `111`
- **D**: ルート → 右 → 左 → `10`

---

### **符号化の結果**
例えば、データ `AABACD` を符号化すると以下のようになります:
- A → `0`
- A → `0`
- B → `110`
- A → `0`
- C → `111`
- D → `10`

符号化結果:
```
00110111010
```

---

### **デコードの仕組み**
デコード時には、ハフマン木を使用してビット列を元のシンボルに変換します。
- ビット列を1ビットずつ読み取り、木のルートから移動します。
- 葉ノードに到達したら、そのノードに対応するシンボルを復元します。

---

この仕組みにより、ハフマン符号化は効率的なデータ圧縮を実現します！